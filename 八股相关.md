## HTTP和HTTPS的区别
- http：超文本传输协议，用于在web浏览器和网站服务器之间传递信息；以明文的方式传递发送内容，不适合传递一些敏感信息；
- https：超文本传输安全协议，提供对网站服务器的身份认证，对通讯内容使用SSL/TLS进行加密，能保护交换数据的隐私和完整性；
`什么是SSL/TLS加密`
CA证书验证过程：（服务器拥有CA证书和自己的私钥，公钥和网站域名提交给CA）
1. 浏览器请求服务器443端口
2. 服务器下发自己的数字证书给浏览器（明文）
3. 浏览器校验CA、有效期、域名；如果有效从操作系统取出证书颁发机构的公钥，根据签名算法得到证书指纹和指纹算法；
4. 浏览器解密拿到公钥，浏览器可以和服务器进行通信

客户端生成对称加密的密钥，利用公钥将对称的密钥加密，传输的过程使用对称加密但解密钥的方法是非对称加密
`对称加密的缺点`
## http的get和post
1. GET--从指定的资源请求数据，传输数据量小，不安全的
2. POST-向指定的资源提交要被处理的数据，可以传输大量的数据，上传文件
3. HEAD--只返回报头不返回文档主体
![[Pasted image 20231228210528.png]]
## 内存泄漏和内存溢出
1. 内存溢出：申请内存的时候，没有足够的内存，出现out of memory；一次加载数据量太大，产生死循环产生过多重复的对象
2. 内存泄漏：new了一块内存，迟迟不delete
**内存泄漏**
4. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。

5. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。

6. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。

7. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。
`基类的析构函数不是虚函数的时候，子类的析构函数将不会被调用，会造成内存泄漏`
`final关键字表示，该方法无法继承`
`override明确表示函数是对基类中的虚函数的重载`

## TCP和UDP
1. tcp是面向连接的，udp是基于非连接的，可靠性低；
2. udp没有建立连接的过程，udp支持一对一，一对多，多对多的交互通信，QUIC协议可靠的udp传输协议；
## 快速排序和归并排序
```cpp
void quicksort(vector<int> &a, int l, int r){
    if(l>=r)    return;
    int i = l-1, j = r+1, mid = a[l+r>>1];
    while(i<j){
        do i++;while(a[i]<mid);
        do j--;while(a[j]>mid);
        if(i<j) swap(a[i],a[j]);
    }
    quicksort(a, l, j);
    quicksort(a, j+1, r);
}
```

```cpp
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;

    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

二分法
```cpp
int l = 0, r = n - 1;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (q[mid] >= x) r = mid;
            else l = mid + 1;
        }

int l = 0, r = n - 1;
            while (l < r)
            {
                int mid = l + r + 1 >> 1;
                if (q[mid] <= x) l = mid;
                else r = mid - 1;
            }

            cout << l << endl;
        }

```

### c++八股
#### 内存管理器，ptmalloc：
linux进程的内存布局分别是：
- 堆区，栈区，程序代码区，全局/静态存储区，常量存储区；
- 分配内存的时候，会在链表中申请一块内存，在开头标注出所使用的大小，在销毁的时候，也会被先放在链表中维护，并在下次用户申请内存的时候，先尝试从链表中的内存需找合适的，这样可以减少系统调用。同时ptmalloc也会对小块的内存进行合并，减少内存碎片；
#### c++11的特性nullptr
- 为了解决c++中NULL二义性的问题，因为NULL实际上代表的是0，而nullptr代表的是`void*`类型；`void*`类型不能隐式转换成以他类型；
- 智能指针
- auto/decltype类型推导  decltype推导变量或者表达式的类型
- Lambda表达式，用于需要一个函数但又不想取名的时候；
```cpp
auto add = [](int a, int b){
	return a+b;
}
// []里面用于捕获外部变量
// [x, &y] x(值捕获) &y(引用捕获)
```
- 智能指针
- thread类和mutex类
#### 特性auto和decltype
- auto对变量进行类型推导；
- decltype可以用于推导变量的类型，函数的返回类型，以及模板函数的返回类型；
```cpp
int x = 5;
decltype(x) y = 10;  // y的类型为int，与x的类型相同

int foo();
decltype(foo()) result;  // result的类型为foo()函数的返回类型

template<typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}
```

#### 线程池怎么解决存在cpu占用长的任务导致其他任务饥饿的问题：
- 可以通过调整线程池的大小，当线程池满了的时候，可以增加线程池的大小，但过多的线程可能回导致线程切换的开销增加；
- 可以设置任务调度的策略：使用不同的任务调度策略来平衡任务的执行，优先级调度策略，优先级高的任务优先执行；公平调度策略：
- 任务分割：可以将耗时较长的任务分割成多个小任务，避免一个任务占用太长的时间；
- 异步执行：占用cpu时间较长的任务，可以将其放在独立的线程或者进程中进行执行，以免阻塞其他任务；

#### 浏览器进行http请求的时候，通常包含哪些头部信息
- user-agent：标识发起请求的浏览器的类型和版本信息用于识别和处理不同的客户端；
- accept：指定客户端接收响应的内容类型，例如html json和字符集utf-8
- accept language：客户端偏好的语言
- referer：页面的url，用于服务器获取请求的上下文信息；
- cookie：之前交互的时候存储的cookie值
- authorization：身份验证信息
- host：服务器的主机名和端口号；

#### std::move和unique_ptr
- 将一个unique_ptr赋值给另一个unique_ptr，需要使用std::move(),使用移动语义来转移所有权；在移动构造函数中，我们将other对象的资源指针移动到当前对象中，并将other对象的资源指针设置为nullptr，以避免重复释放资源。unique_ptr可以对指针指向的对象进行访问和修改；

#### 设计一个线程安全的单例模式
单例模式只有一个实例可以被创建，实例可以通过全局访问点进行访问，通过静态成员变量保存实例；用互斥锁来保证只有一个线程可以创建实例；

其他：`__thread`关键字可以保证每个线程有一份独立的实体，各个线程的值互不干扰，常用于多线程编程中，特别是再需要为每个线程分配独立的变量实例时，可以提供线程安全性和线程间的数据隔离

#### unique_lock和lock_guard的区别
- `std::lock_guard<std::mutex> lock(latch_);`构造时自动锁定互斥锁，并在析构时自动解锁互斥锁，lock_guard的生命周期和latch_的生命周期一致，无法手动解锁或者重新锁定互斥锁；
- unique_lock运去选择是否锁定互斥锁，并在需要的时候，手动锁定和解锁互斥锁；

### 进程和线程的区别
- 进程是cpu和内存等资源分配的基本单位
- 线程是进程中能独立运行和独立调度的基本单位，线程拥有`程序计数器，寄存器，栈`，多个线程共享同一个进程内的资源，使用相同的地址空间；
- 线程之间的通信更加方便，同一个进程中的全局变量和静态变量都可以直接进行访问；线程的调度和切换都比切换进程开销小很多；但多进程程序要更有鲁棒性，一个进程死了不会对其他进程造成影响， 如果主线程死了可能导致进程终止，存在共享资源的时候，如果一个线程死了，可能会造成无法访问这些资源；
- ==进程之间的通信方法==： ==管道==单向的通信机制，匿名管道在内存中创建，命名管道在文件系统中创建，一个进程作为写入，另一个进程作为读取，只能用于父子进程间的通信；==共享内存==，==消息队列==， ==信号量==：可以确保进程间的同步，进程间的运行顺序；==套接字== socket可以实现不同主机之间的进程进行通信；

### 业务中一个订单被重复提交两次如何解决
- 将每一次用户的请求用一个request-id进行记录，对于重复发送的请求，request-id应该是相同的，这时候校验id是否已经存在，request-id可以存储在redis数据库或者mysql中；

### TCP为什么要三次握手
- tcp建立连接的时候，三次握手能防止历史连接的建立，减少双方不必要的开销，帮助双方同步初始化序列号，序列号能保证数据包不重复、不丢弃和按序传输；
- 两次握手，无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；

### tcp网络攻击，如何应对SYN flood攻击
- **SYN FLOOD攻击**  攻击者发送大量的TCP、SYN请求到目标服务器，在收到服务器的SYN+ACK响应后不发送ACK确认，导致服务器上留下大量的等待完成的半开连接，耗尽服务器的资源，使正常的TCP连接无法建立；
- **TCP会话劫持** 窃取tcp会话中的序列号等信息，然后冒充合法用户接入到会话中，攻击者可以监听网络上的tcp会话，分析并预测序列号，然后发送伪造的数据包，中断或者篡改原有的会话内容；
- **TCP重置攻击** 攻击者发送伪造的tcp rst(重置)数据包到目标主机，中断正常的tcp连接，接收到rst数据包的时候，连接的两端都会关闭连接，使得攻击者可以中断服务或者进行拒绝服务攻击；

- `如何避免syn flood攻击`：1. 启用syn cookie技术，通过cookie来验证TCP连接的合法性，服务器在收到syn请求时会计算一个cookie，并发送给客户端，客户端在后续的ack报文中携带该cookie，服务器通过验证cookie的合法性来判断；2. 调整tcp协议栈参数：减少syn timeout，使得服务器更快的释放无效的连接请求，增大tcp连接的队列长度，提高服务器处理连接请求的能力，启用tcp fast open，加快tcp建立连接的过程


### unordered_map和unordered_set的区别
- map内部实现了一个红黑树，红黑树是非严格平衡二叉树，而AVL是严格平衡二叉树；红黑树有自动排序功能，因此map内部的元素都是相对有序的；
- unordered_map内部实现哈希表，元素的排列顺序是无需的；unordered_map占用内存要比map高；
- set实现了红黑树的平衡二叉检索树，set每个元素的值都是唯一的。系统根据元素的值进行排序
- unordered_set内部哈希表，元素排列都是无需的

### priority_queue

- 优先队列自动维护堆的最大or最小值，greater维护最小值，less维护最大值；可以重载pair类型
- ` priority_queue<pair<int,int>, vector<pair<int, int>>, greater<pair<int, int>>> `也可以直接使用，默认对pair.first进行排序，注意pair的first和second不需要加括号；

### cookie和session的区别
- cookie存储在客户端，session是服务端的数据，cookie对大小有限制，一般session对大小没限制；cookie只能存ascii，session一般没限制；
- 在客户登陆的时候，服务器会给客户端发送一个session，可以存在session storage中，然后在进行操作的时候就通过session storage中存的token进行身份认证；

http的缓存有哪些实现方式：强制缓存和协商缓存，强制缓存指只要浏览器判断缓存没有过期就直接使用浏览器的本地缓存；协商缓存就是与服务器端协商之后，通过协商结果来判断是否使用本地缓存；304响应码

http的默认端口是80，https默认端口是443，https在三次握手之后，还需要进行ssl/tls的握手过程
混合加密的方式：通信建立前采用非对称加密的方式交换会话密钥；通信过程中采用对称加密的方式 用交换的会话密钥 对明文进行加密；

对传输的内容计算出一个指纹，对方收到消息后，确认指纹内容，判断信息是否被修改；

ca证书：个人信息+公钥+数字签名 认证；

- 进程持有的虚拟地址会通过cpu芯片中的内存管理单元mmu的映射关系来变成物理地址；
进程虚拟地址 ---> cpu --虚拟地址-> `mmu` ---> 物理地址
内存分段和内存分页；分段就是基地址+偏移量；存在的问题是内存碎片问题和内存交换的效率低的问题；
内部内存碎片和外部内存碎片：内存分段管理可以按需分配内存，不会出现内部碎片问题；
外部碎片问题：多个段未必能恰好使用所有的内存空间，会产生多个不连续的小物理内存，出现外部内存碎片问题；
linux系统中的swap空间，从硬盘中划分出来，用于内存和硬盘的交换；就可以先把碎片后的部分交换到硬盘的swap空间，然后在按顺序交换回来；
页表存在内存中，当虚拟地址在页表中查不到时，系统会产生一个缺页异常，系统进入内核空间分配物理内存、更新进程页表、最后再返回用户空间恢复进程的运行；
- 把虚拟内存地址切分成页号和偏移量；根据页号从页表中查到对应的物理页号，虚拟地址转换为物理地址访问物理内存的位置；
先进行段式映射然后进行页式映射；linux系统的每一个段都是从0地址开始的4GB虚拟空间；所有的段的起始地址都是一样的；内核空间和用户空间；内核空间1G，用户空间4G;进程在用户态只能访问用户空间的内存；进入内核态之后才能访问内核空间的内存；每个进程都有独立的虚拟内存，但虚拟内存中的内核地址关联的式相同的物理内存；
内核空间 ---> 栈 ---> 文件映射 ---> 堆 ---> BSS ---> 数据段 ---> 代码段
- bss：未初始化的静态变量和全局变量；数据段初始化的静态常量和全局变量；
- 文件映射段：动态库、共享内存等等；
`mmap()`将文件或设备的内容映射到进程的地址空间中，并将页面与文件关联，实现了内存与文件之间的映射
- mmap() 方法：适用于将文件内容映射到内存中进行读写操作，以及创建共享内存区域用于进程间通信。mmap() 方法可以实现高效的文件 I/O，特别适用于处理大型文件或需要随机访问文件内容的场景。此外，mmap() 还可以用于创建匿名内存映射区域，用于进程间的数据交换或临时存储。实现零拷贝读写---**什么是0拷贝读写**
- 推进 brk 指针：适用于动态分配和释放内存块，通常用于管理堆区的内存分配。通过调整 brk 指针，可以增加或减少堆区的大小，从而分配或释放相应大小的内存块。这种方式常用于实现动态数据结构，如动态数组或链表。
#### 在这里详细写一下mmap
- **文件映射**：当调用mmap()函数的时候，系统调用会创建一个文件映射，将文件的内容映射到进程的地址空间的页表中；
- **懒加载**：当进程访问映射区域的时候，才会将文件的内容加载到内存中；
- **写时复制**：对于共享映射区域，通常使用写时复制(COW)，当多个进程共享一个映射区域的时候，当一个进程尝试修改数据的时候，才会复制数据，保证每个进程都有自己的数据副本；


malloc()在堆区分配内存；mmap()在文件映射段分配内存；
**什么是cpu的tlb，局部性原理是什么**：tlb用于加速虚拟地址到物理地址的转换过程；tlb是内存管理单元mmu中的一个高速缓存，用于存储最近使用的虚拟地址到物理地址的映射结果，以提高地址转换的速度；
局部性原理包括：空间局部性原理和时间局部性原理；
TLB的工作流程如下：
1. 当cpu执行指令时，如果需要进行虚拟地址到物理地址的转换，首先要检查tlb中是否存在对应的映射结果；
2. 如果命中直接从tlb中获取物理地址；否则通过页表等进行地址转换然后将结果存在tlb中；

**系统调用**：用于访问操作系统的功能和资源；应用程序通过系统调用可以请求操作系统执行特权的操作，如文件操作、网络通信、进程管理、内存管理等；
- 系统调用的实现方式通常是通过软中断或陷阱指令来触发的：
	- 应用程序调用系统调用接口，接口函数通常是由操作系统提供的库函数封装的；
	- 切换到内核态
	- 传递参数
	- 执行系统调用
中断异常
[深入理解中断，异常，系统调用_异常与系统调用的区别?-CSDN博客](https://blog.csdn.net/wb_snail/article/details/105369880#:~:text=2.1.%E4%B8%AD%E6%96%AD%EF%BC%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E7%9F%A5%E9%81%93%E5%A4%96%E8%AE%BE%E4%BD%95%E6%97%B6%E5%8F%91%E5%87%BA%E4%BA%86%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8%E6%A3%80%E6%B5%8B%E5%88%B0%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7%E5%90%8E%EF%BC%8C%E4%BC%9A%E5%88%87%E6%8D%A2%E5%88%B0%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F%E5%8E%BB%E5%A4%84%E7%90%86%EF%BC%8C%E5%AE%8C%E6%88%90%E5%90%8E%E5%86%8D%E5%88%87%E6%8D%A2%E5%9B%9E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%AF%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%98%AF%E9%80%8F%E6%98%8E%E7%9A%84,2.2.%E5%BC%82%E5%B8%B8%EF%BC%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%88%B0%E5%BC%95%E5%8F%91%E9%94%99%E8%AF%AF%E7%9A%84%E6%8C%87%E4%BB%A4%E5%90%8E%EF%BC%8C%E7%AB%8B%E5%8D%B3%E8%A7%A6%E5%8F%91%E5%BC%82%E5%B8%B8%E4%BF%A1%E5%8F%B7%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%8C%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E6%9D%80%E6%AD%BB%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B%EF%BC%8C%E6%88%96%E8%80%85%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C%E4%BA%A7%E7%94%9F%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8C%87%E4%BB%A4%202.3.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%91%E8%B5%B7%E8%B0%83%E7%94%A8%E6%97%B6%EF%BC%8C%E8%A7%A6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BF%A1%E5%8F%B7%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E5%8F%AF%E8%83%BD%E4%B8%BA%E5%90%8C%E6%AD%A5%E5%8F%AF%E8%83%BD%E4%B8%BA%E5%BC%82%E6%AD%A5%EF%BC%8C%E6%AF%94%E5%A6%82%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AF%B7%E6%B1%82%E8%AF%BB%E4%B8%80%E5%9D%97%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%8F%91%E5%87%BA%E5%90%8E%E7%AD%89%E5%BE%85%E6%95%B0%E6%8D%AE%E5%B0%B1%E7%BB%AA%E5%90%8E%E6%89%8D%E6%8E%A5%E7%9D%80%E5%B9%B2%E5%85%B6%E4%BB%96%E4%BA%8B%E6%83%85%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%8F%91%E5%87%BA%E5%90%8E%E5%B0%B1%E5%B9%B2%E5%85%B6%E4%BB%96%E4%BA%8B%E6%83%85%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%84%E7%90%86%E5%AE%8C%E6%88%90%E5%90%8E%E5%8F%91%E5%87%BA%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)
- 中断、异常和系统调用；
- 中断的来源是外部的io设备；异常是应用程序执行过程中出现了意料之外的事情；系统调用是应用程序明确要求操作系统提供某个服务比如：打开文件、关闭文件、读写文件、发送网络包等等；
- 硬件处理和软件处理相结合：中断：外部硬件设备需要服务的时候会设置中断标记cpu检测到这个标记然后根据标记得到中断号，将中断号发送给操作系统，操作系统根据中断号在中断向量表中找到处理程序的地址，在跳转到处理程序之前，操作系统保存被打断程序的执行现场，处理完成后恢复之前保存好的程序执行现场；这个跳转和恢复的过程称为上下文切换；
- 应用程序运行时，会对一些特定的服务比如文件读写、网络包传输等等，使用系统调用的接口；用户态和内核态的划分，分为ring0~ring3四个级别，用户态属于ring3权限最低，内核态属于ring0权限最高；
- ring1和ring2(特权模式)：是一些特殊的操作系统或者虚化软件使用的特权级别；一些操作系统或虚化软件使用这些特权级别来实现虚拟化、设备驱动程序等等；
- 应用程序发出系统调用后，需要进行参数验证；
- 涉及到数据读写时，存在内核态和用户态的数据拷贝；

- 随着系统频繁的malloc和free，尤其对于小块内存，堆内将产生越来越多不可用的碎片，导致内存泄漏；free会对传入的内存地址



### 在c++中，类的public部分定义一个数组是不允许的
有两种方法： 
1. 私有部分定义一个数组，并在构造函数或者初始化列表中对其进行初始化；
```cpp
class MyClass{
	private:
		int a[10010];
	public:
		MyClass() {
			memset(0, a, sizeof(a));
		}
}
```
2. 使用c++11引入的初始化列表的语法：
```cpp
class MyClass{
public:
	int a[10010] = {};
}
```
所有类类型的成员都会在初始化阶段初始化，即使没有出现在构造函数的初始化列表中；
初始化列表直接在对象的构造时对变量进行初始化，避免了先调用默认构造函数在进行赋值；初始化常量成员变量；初始化引用成员变量；没有默认构造函数的类类型，因为使用初始化列表可以不用调用默认构造函数来初始化，而是直接调用拷贝构造函数进行初始化；


### 内存满了会发生什么
- 硬盘上的swap区域，是计算机系统中用于拓展物理内存的一部分；当物理内存不够容纳当前运行的进程和数据时，操作系统可以将某些内存页面移出物理内存，并存储到硬盘的交换区域中；`响应时间延长和系统吞吐量下降等情况`
- 进程没有办法访问其他进程的页表，解决了多进程之间地址冲突的问题；
- 新建虚拟内存的时候并不会分配物理内存；虚拟内存发现没有映射到物理内存，cpu就会产生缺页中断；进程会从用户态切换到内核态，交给内核的缺页中断函数处理；如果有就直接建立物理内存；否则就会进行==回收内存==的工作：直接内存回收和后台内存回收
	- **后台内存回收**：物理内存紧张的时候，会唤醒kswapd内核线程来回收内存，这个回收内存的过程是异步的，不会阻塞进程的执行；
	- **直接内存回收**：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，回收时同步的，会阻塞进程的执行；
如果直接内存回收后，仍无法满足物理内存的申请；OOM killer机制会根据算法选择一个占用物理内存较高的进程，将其杀死直到释放出足够的内存位置；
```
kswapd后台内存的回收步骤：
	1. 检查内存压力：kswap定期检查系统的内存使用情况，包括可用内存的数量，页缺失的频率，如果内存不足就会启动内存回收过程；
	2. 选择页面：页面回收算法LRU最近最少使用原则，用来确定那些页面最适合被移除物理内存；
	3. 写回脏页面；
	4. 移除页面；
	5. 更新内存管理的数据结构，以反映页面的状态变化，包括更新页面的状态和更新页面访问的时间戳；
```
- 主要有那些内存可以被回收：
1. 文件页：回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存；
2. 匿名页：比如堆、栈数据等；不能直接释放内存，它的回收方式是通过linux的swap机制，swap会把不常访问的内存先写到磁盘中，然后释放这些内存；再次访问的时候，再从磁盘读入内存就可以了；匿名页换入换出两个操作都会发生磁盘io，消耗比较大。
`linux提供了一个swappiness选项，用来调整文件页和匿名页的回收倾向，数值越小越消极使用swap，更倾向于回收文件页`
- 如何查看系统的直接内存回收和后台内存回收的指标：`sar -B 1`
应该尽早触发[后台内存回收]，来避免应用程序进行直接内存回收；
	- 页最小阈值：
	- 页低阈值：
	- 页高阈值：
![[Pasted image 20240321133854.png]]
- 在橙色部分时会触发内存回收kswapd，直到剩余内存大于高阈值，但不会阻塞应用程序因为二者的关系是异步的；
- 红色部分会触发直接内存回收，应用程序会被阻塞，二者关系是同步的；直接内存回收是在请求释放内存的进程上执行的，而不是由后台进程负责；
	1. 内存释放请求：当一个进程需要释放一部分内存时，会向操作系统发出内存释放请求；
	2. 内存回收器执行：操作系统的内存回收器会对接收到的内存释放请求进行处理，回收器可以是内核中的一部分，也可以是用户空间的库或工具；
	3. 页解绑和回收：内存回收器会解除请求进程和要释放的内存页面之间的绑定关系，将页面标记为可回收状态；
	4. 回收策略：LRU最近最少使用原则、LFU最不经常使用等；

- SMP架构：多个cpu共享资源的电脑硬件架构；一致存储访问结构(UMA)，多个cpu都通过一个总线访问内存，这样总线的压力越来越大，每个cpu可用的带宽会减少；
- NUMA非一致性存储访问结构：每个node有自己独立的资源，包括内存和io等，每个node之间可以通过互联模块的总线QPI进行通信，每个node上的cpu可以访问所有内存，但访问远端Node的内存比访问本地内存要耗时很多；但相比内存回收的危害，访问远端的node带来的性能影响还是比较小；

- 保护一个进程不被OOM杀掉：内存空间不足进程申请了一个更大的内存，如果无法回收出足够大的空闲内存，就会触发oom机制，内核会根据算法选择一个进程杀掉；
`linux内核有一个oom_badness()函数，把可以杀掉的进程扫描一遍，并对每个进程打分得分最高的进程就会被首先杀掉：得分受两方面影响：1. 进程已经使用的物理内存页面数；2. oom校准值`

### 4gb的物理内存的机器申请8g的内存会怎么样
- 32位操作系统，进程最多只能申请3gb大小的虚拟内存空间，所以如果申请8gb内存，在申请阶段就会失败；
- 64位的操作系统进程可以使用的最大空间是128tb虚拟内存空间，所以申请8G的虚拟内存是没问题的
	- 和linux中的overcommit_memory参数也有关系，如果0默认值，就允许overcommit的那太大就会拒绝，比如malloc一次申请的内存大小超过了系统的总内存；1代表永远允许overcommit；2代表禁止overcommit；
	- 如果再开启swap机制就真的可以申请到大概127Tb更多的虚拟内存；==如果申请的物理内存大小超过了空闲的物理内存大小==如果开启了swap机制就可以，如果没有开启swap机制，就会oom，强制kill一些进程；
	- linux提供了两种不同方法启用swap，分别是swap分区和swap文件；swap分区是硬盘上的独立区域，该区域只会用于交换分区，其他文件不能存在该区域、swap文件是文件系统中的特殊文件

### 关于改进LRU算法
	预读失败问题：导致缓存命中率下降缓存污染：导致缓存命中率下降
- redis的缓存淘汰算法是通过LFU实现的，redis没有预读机制；把最低访问的页面用于置换
- mysql和linux都是通过改进lru算法实现的


### malloc/free和new/delete的区别
- malloc和free是库函数，仅仅分配内存和释放内存，不会调用构造函数和析构函数，意味着使用malloc分配内存需要手动进行初始化和清理；new和delete会调用对象的构造函数和析构函数；
- malloc按字节对齐，需要手动保持数据结构的对齐；new按对象的要求进行对齐；
- malloc不支持调用数组元素的构造函数和析构函数，new[] delete[] 会调用数组元素的构造函数和析构函数；

# 动态绑定和虚函数，多态
- 基类指针或者引用指向不同的派生类对象时，调用虚函数，最终调用的是指向对象对应的派生类自己实现的虚函数；
- 如果类中有虚函数，将虚函数的地址记录在类的虚函数表中，派生类在继承基类的时候，如果有重写基类的虚函数，在虚函数表中相应的指针设置为派生类；每一个包含虚函数的类都有一个虚函数表，虚函数按照其声明的顺序放在表中，父类的虚函数在子类的虚函数前面；
- ==有虚函数覆盖==：虚函数在派生类中也被声明为虚函数了，那么虚函数表中原来父类虚函数的位置就会变成现在这个虚函数，覆盖了原来的函数；
- 虚函数表属于类，类的所有对象共享这个虚函数表，虚函数指针属于实例；
	- 同一个类的对象共享一个虚函数表；
	- 类存在虚函数表，那么类的地址的起始位置存放虚函数表的地址；
	- 子类继承父类虚函数表中的虚函数地址数据，如果子类重写虚函数为新的虚函数那么会覆盖；
- 多态体现在运行和编译两个方面，运行时多态通过继承和虚函数来体现，编译时多态体现在函数和运算符的重载上；
==静态分配和动态分配的区别==：静态分配是指编译时为对象分配一个固定大小的内存空间，对象的生命周期与作用域相关联；
#### 重载和重写的区别
重载：函数名相同，参数列表不同；早绑定和多态无关
重写：子类重写父类的方法；晚绑定：在运行期间绑定；

### initialization list和assignment 初始化列表和赋值
- 什么是初始化列表/赋值
```cpp
// 初始化列表
MyClass(int a, int b) : x(a), y(b) {
        // Constructor body
    }
};
// 赋值方法
MyClass(int a, int b) {
    x = a;
    y = b;
}
```
- 引用类型和const类型都必须在初始化列表中对其进行初始化；
- 子类的构造函数需要初始化父类的private成员，需要调用父类的构造函数，需要初始化列表；
```cpp
Child(int value) : Parent(value) {
        // 子类构造函数通过调用父类构造函数间接初始化父类的私有成员
}
```


### template模板类---泛型编程
- 模板默认内联，没有虚函数表，调用的开销小
- ==导致编译太慢，编译出的可执行文件太大==：1. 减少switch case，2. 减少不必要的模板参数，3. 减少模板的调用层级；
- 模板的缺点：编译速度慢和更占用内存；
- c++中引用了拖尾返回类型==trailing return type==，允许在函数定义时延迟指定函数的返回类型；
```c++
auto fcn(It beg, It end) -> decltype(*beg){
	return *beg;
}
```
`remove_reference<>`:模板元函数，从一个类型中移除引用修饰符（&，&&）就是去掉引用类型后的类型；

# c++的编译过程
- ==预处理阶段==：`#include`,`#define`预处理会将所有头文件包含到源文件中，展开宏定义并去除注释；
- ==编译 - 汇编==：将源代码转换为汇编代码`.s`文件，然后将汇编代码转换为目标代码`.o`文件
`.s文件是汇编代码的文件，.o文件是目标文件-二进制代码文件`
- ==链接==：将目标文件与所需的库文件链接在一起，生成可执行文件，解析符号引用，符号地址被解析为实际的内存地址；
	1. 符号解析：链接器将目标文件中的符号变量进行解析，找出符号的定义在哪；`全局符号`编译阶段会被赋予一个地址，在编译单元内或跨编译单元之间使用；`未定义符号`编译阶段不会被赋予地址，在链接阶段将其解析为实际的地址，通常由链接器来完成；
	2. 地址绑定：**静态绑定**：确定符号的内存地址，生成绝对地址的目标文件；**动态绑定**：在加载可执行文件时，动态链接器将符号与地址关联，生成可执行文件；
	- 静态链接：函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中，程序在被执行时这些代码将被装入进程的虚拟地址空间中；==特点：.a\.lib 浪费空间但运行速度快== 
	- 动态链接：函数的代码放在动态链接库或共享对象的某个目标文件中；==动态链接库.dll或共享对象.so==：程序运行时才会被加载到内存中，而不是在编译时静态的链接到可执行文件中；多个程序可以同时使用同一个动态链接库或共享对象，节约内存空间；==特点：速度慢，节省空间，每次执行的时候都需要程序进行链接==
		`如果 `sum()` 函数在静态库中，链接器会将 `sum()` 函数的代码复制到最终的可执行文件中；如果 `sum()` 函数在动态链接库中，链接器会记录对该库的依赖关系，以便在程序运行时动态加载该库。`
#### 静态库和动态库中的lib有什么区别
`lib`：指库文件library file，静态库static library，动态库static library；`静态库`中的lib：包含了函数代码本身，在编译时直接将代码加入程序当中；`动态库`中的lib，包含了函数所在的dll文件和文件中函数位置的信息索引，函数的实现代码在运行时用进程空间中的dll提供；

## 引用和常引用
- 引用是某个变量的别名，==引用本身不占存储单元，系统也不给引用分配存储单元，不能建立数组的引用==
- 常引用`const int &ra = a;` 引用型参数应该在能被定义为const的情况下尽量定义为const
`因为在c++中临时对象都是const类型的，将const类型转换为非const类型是非法的`——可以使用`const_cast<int&>(x)`用于去除指针或引用的const属性；
- 引用作为函数返回值，内存中不产生返回值的副本，但返回一个局部变量的引用不行，因为局部变量的生命周期结束，引用会失效会产生`runtime error`；
`函数内部使用new动态分配内存创建对象，后除非显示调用delete释放内存，就会导致内存泄露，这部分内存无法被程序访问，直到程序结束才会被回收；`

### 函数传递参数的时候，什么时候使用指针，什么时候使用引用
- 返回函数内部局部变量内存需要使用指针；返回局部变量引用没有意义；不过使用指针传参后需要释放指针否则会造成内存泄漏；
- 对栈空间大小比较敏感的时候使用引用，因为引用不需要创建临时变量，开销比较小；比如递归
- 类对象作为参数

### 返回值优化(RVO)和拷贝消除(Copy Elision)
- 通过在不创建临时对象的情况下直接在调用方的对象内存中构造函数的返回值，从而避免了对象的拷贝操作；

## 在main函数执行前和执行后都会发生什么
- 在main函数执行前：1. 设置栈指针；2. 初始化static变量和global全局变量，.data段；3. 将为初始化的变量设初始值，初始化.bss段；4. 全局对象初始化，在main前调用构造函数；5. main参数传给main函数；
- main执行后：1. 执行全局对象的析构函数；


### 智能指针
```cpp
// shared_ptr\unique_ptr\weak_ptr
std::unique_ptr<int> ptr1 = std::make_unique<int>(42);//移动构造unique_ptr
std::unique_ptr<int> ptr2;
ptr2 = std::move(ptr1);

```
1. shared_ptr:允许多个指针指向同一个对象，当所有智能指针都被销毁的时候，自动进行回收
2. unique_ptr:独占对象不支持复制和赋值，使用std::move() 移动构造；
3. weak_ptr: 不能访问对象，可以用来监视shared_ptr的生命周期；可以通过`auto locked = weak.lock()`的方法，转换为shared_ptr；当目标被销毁的时候，weak_ptr自然指向null因此不存在野指针的问题；
`前置知识：当两个或多个对象互相持有对方的shared_ptr的时候，就会出现循环引用问题，导致引用计数永远不会变为0，导致内存泄漏`
```cpp
#include <iostream>
#include <memory>

int main() {
    // 创建一个 shared_ptr
    std::shared_ptr<int> shared = std::make_shared<int>(42);
    // 创建一个 weak_ptr
    std::weak_ptr<int> weak = shared;
    // 尝试访问 shared_ptr 中的值
    if (auto locked = weak.lock()) {
        // 如果资源仍然存在，使用 locked 指向的资源
        std::cout << "shared_ptr 指向的值为: " << *locked << std::endl;
    } else {
        // 如果资源已经被释放
        std::cout << "资源已经释放" << std::endl;
    }

    return 0;
}
```
make_shared分配内存只分配依次，而new初始化至少要分配两次内存


# STL相关
#### STL线程不安全怎么解决
- 假设对于vector，即使`写方是单线程写入（即线程安全的）`，但在并发读取的过程中，由于可能写入操作会导致迭代器失效，导致core dump；多个写入，基本上一定会导致core dump
1. 一种解决办法是：加互斥锁，std::mutex，或者加读写锁来缓解
2. 可以通过固定vector的大小避免动态扩容；可以通过resize的方法提前准备1000个初始化的元素
	`vector<data> v; v.resize(1000)`
如果没法预期多少个元素进行初始化，也可以将vector设计成环形队列，避免重复消费有以下两种方法：

1. `std::atomic<size_t> head`这里size_t是无符号整数类型，head用于存储队列的头
```cpp
auto head_current = head.load() // 用于读head的内容
haed.shore((current_head+1)%1000) // 用于存head的内容
```
2. 还有一种方法是，ABCDE五个消费者，比如A 只取1，6，11...每个读线程各自维护自己当前消费的最新下标；
`以上是顺序类容器的处理方法`
 对于关联性容器：map unordered_map等等
==加锁==
不加锁的方案：比如在并发操作之前就拿到所有的key，然后全部insert，不过多个线程修改一个key的时候还是会出问题，可以对key进行分段加锁，减少锁冲突的概率；

### 为什么关联性容器的插入效率一般比较高
- 关联性容器不需要内存拷贝和内存移动，变换的只有指针而没有内存移动；

### 什么时候会导致迭代器失效
1. vector: 插入一个元素后end迭代器会失效，如果vector的大小没有改变，first迭代器不会失效；删除操作，被删除的元素和后面的元素都会失效；
2. list（链表）：删除时，被指向的元素的迭代器会失效；
3. deque（双端队列）：在首部和尾部插入元素不会失效，但在其他地方插入元素会使所有迭代器失效；
`vector的iter = v.erase(iter)`删除这个元素会返回下一个有效的迭代器（list的erase方法也会返回下一个有效的迭代器）；

### unordered_map
unordered_map的底层使用hashtable，采用拉链法用桶解决哈希冲突（使用一个链表存储哈希到同一个位置的键值对），当桶的大小超过8的时候自动转换为红黑树；（常用的方法就是开放寻址法和拉链法）
```
一个红黑树的每一个节点通常包含一个键值对（key-value pair），左子节点指针，右子节点指针，父节点指针以及颜色信息；
红色节点的父节点和子节点都不是红色，也可以没有子节点；黑色节点可以有红色的子节点也可以没有节点；
根节点是黑色的，保证从·根到叶子的每条路径上黑色节点的数量相同·；
新插入的节点默认是红色，后通过旋转和重新着色来保持红黑树的性质；
```


# 进程与线程
#### 进程与线程的区别与联系
1. 进程是cpu调度的基本单位，线程是程序执行的最小单元，一个进程由多个线程组成，同一个进程的线程共享数据段、代码段、堆区、BSS、文件映射区、共享库，但有独自的栈
#### 线程同步的四种方式
`POSIX(Portable Operation System Interface for Unix)`可移植操作系统；
POSIX信号量：允许进程在共享资源上的访问上进行协调，通过信号量的方法确保只有一个进程可以访问临界区，实现进程间同步；
POSIX互斥锁＋条件变量：只能用于线程同步；
1. 临界区：多个线程访问一个独占性的共享资源时，可以使用临界区对象，一个线程拥有临界区，直到这个线程放弃临界区；`临界区是程序中的一段代码，用于访问共享资源的代码块或区域`
2. 事件event：一个线程处理完任务后，主动唤醒另一个线程执行任务；
3. 互斥量：Mutex
4. 信号量：当需要一个计数器来限制共享资源的线程数量时，使用信号量。`当计数器为0时，所控制的资源的访问尝试被放入到一个队列中等待， 直到超时或计数器不为0为止`

#### 进程间通信的方式
1. 管道
2. 套接字
3. 信号量：一个计数器
4. 信号：
5. 共享内存
6. 消息队列

### 一个程序中创建多少线程比较合适
1. 对于cpu密集型任务，只有多核cpu才能实现加速，所以cpu核数+1就行
2. io密集型任务：（cpu核数+1）* 2 or  (（线程 CPU 时间+线程等待时间）/ 线程 CPU 时间 ) * 核心数 N

#### 进程与线程切换的区别
进程切换需要切换页表和指令，而线程切换只需要切换指令

#### 父子进程间有那些资源是共享的，哪些是独有的
共享代码段和文件共享，不共享数据段和堆栈空间


## 生产者消费者模型
1个场所：缓冲区；2个角色：生产者、消费者；3种关系：生产者与消费者之间的同步与互斥关系，生产者与生产者之间的互斥关系，消费者与消费者之间的互斥关系；
###### 通过信号量实现
- 使用vector创建循环队列，包含front队头和rear队尾；
- 需要三个信号量：一个互斥信号量，一个信号量表示空闲资源，一个信号量表示正在使用资源；`sem_t _full, sem_init()初始化信号量, sem_wait()等待信号量, sem_post()释放信号量`
`sem_wait(sem_t *sem)`:  等待信号量的值-1， 若信号量的值小于0那么会被阻塞
`sem_post(sem_t *sem)`：增加信号量的值，
**信号量要放在mutex前，否则会发生死锁**
##### 通过条件变量实现
条件变量放在mutex后，先用互斥锁加锁，在对条件变量进行wait操作，因为条件变量的`pthread_cond_wati`操作结合了互斥锁解锁，判断条件变量的条件是否达成，再对互斥锁加锁，不会出现死锁的情况；
```cpp
// 实现互斥关系的互斥锁 
pthread_mutex_t _mutex; 
// 实现同步关系的条件变量 
pthread_cond_t _pro_cond; 
pthread_cond_t _cus_cond;

pthread_mutex_lock(&mutex);
// 临界区代码
pthread_mutex_unlock(&mutex);
pthread_mutex_destroy(&mutex);


pthread_cond_init(&cond, NULL);
// 比较推荐下面这种处理方法：把条件变量放在mutex中间
pthread_mutex_lock
xxx
pthread_cond_signal
pthread_mutex_unlock

// 但下面这种方法也是正确的
pthread_mutex_lock
xxx
pthread_mutex_unlock
pthread_cond_signal
```

## 死锁相关
#### 如何避免死锁
1. 以确定的顺序获取锁；2. 超时放弃；3. 检测死锁，立刻将进程从死锁状态解脱出来发（银行家算法）p247 p166
`银行家算法：银行家算法通过检查每个进程的资源请求是否使系统处于安全状态来决定是否分配资源。如果分配资源后系统仍然处于安全状态，则分配资源；否则，拒绝资源请求，避免可能导致死锁的情况发生。`

# socket相关
	客户端：socket()->connect()->write()->read()->close()
建立socket 创建连接 发送请求 收请求 关闭
	服务端：socket()->bind()->listen()->accept()->read()->write()->read()->close()
建立socket 绑定 监听 接受请求 发送请求 关闭
![[C++八股文.pdf#page=250&rect=-1,110,595,412|C++八股文, p.250]]
#### shutdown()和close()的区别
shutdown可以通过指定的标志：`SHUT_RD`, `SHUT_WR`, `SHUT_RDWR` 终止一个方向上的连接：比如`SHUT_WR`之后还可以继续读数据但不能在写入了，`close()`是在两个方向上都终止连接；p251
	**使用close()终止连接的时候会发生什么**：
	1.  发送FIN包表示本端不再发送数据，但仍会接受数据
	2. 等待对端ack确认接收到fin包，同意关闭连接
	3. 对端发送一个FIN用来关闭数据传输，然后对端进入LAST_ACK状态
	4. 进入time_wait状态：确保对端接到了最后一个ack包，一般等待时间是2倍最大报文生命周期; 本端发送最后一个ack包，确认对端的关闭请求，然后彻底关闭连接；
`TIME_WAIT`状态用来确保客户端最后一个ack报文可以到达服务端，如果没收到服务端就会超时重传FIN+ACK报文，就会在确认一次然后重启time_wait状态；

## 半打开与半关闭
- 半开连接：由于一个tcp连接需要三次握手，把这三次握手之前都成为半连接；
- 半关连接：只有一方发送了FIN另一方没有发出FIN包，仍可以在一个方向上正常发送数据；

# TCP相关
`七层网络模型：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层`
### TCP头部有那些信息
- 序号：初始序号会被设置成一个随机的初始值ISN， 而后根据数据在字节流中的偏移，确定下一段序号`假设A -> B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。` ==ISN序列号(Initial Sequence Number)==
- 确认号：接受方对发送方tcp报文段的响应，收到的序号值+1
- 首部长（数据偏移）：标识TCP头部的长度
- 标识位：
![[Pasted image 20240711142106.png]]
- 窗口：接收窗口，用于告知对方，本方的缓冲还能接受多少字节的数据，用于解决流量控制问题；
- 校验和：接收端用CRC检验整个报文段有无数据损坏；
- 源端口号和目标端口号

### 常见的TCP连接状态有哪些
- close关闭、listen监听、syn_send客户端connect连接、syn_recv服务端接收syn包、establish确认连接三次握手之后
- ![[Pasted image 20240711142914.png]]
`TIME_WAIT`究竟有什么用：如果服务端发送完FIN之后，没收到ACK，那么就会再发送一次FIN，TIME_WAIT就是在给服务端再次发送的缓冲时间，如果缓冲时间过了还没再次受到FIN默认已经关闭了；

### 为什么使用随机的序号而不是用固定的序号
- 首先：在TCP连接的整个生命周期中，序列号会随着数据传输的增加不断增加，以确保数据的有序传输和正确重组；且TCP的序列号是一个32位的值，达到最大值后会绕到0重新开始
- 使用随机的序列号是出于安全性考虑：攻击者可以按照序号预测下一个序列号，造成安全问题

### TCP为什么不可以两次握手
- 三次握手才能同步双方的序列号，避免浪费资源
- **最关键的原因是**：三次握手可以阻止重复历史连接的初始化；如果只有两次握手，服务器端直接就是建立连接的状态，无法通过客户端阻止错误的连接；服务端直接就是建立连接的状态也无法判断客户端现在是不是可以接收数据的状态；

#### 什么是TCP的端口复用
使用相同的本地ip地址和本地端口与不同的远程ip地址和远程端口建立多个连接的能力
和epoll的io多路复用不一样，io多路复用指的是在单线程中处理多个输入输出；

### TCP是如何实现可靠传输，流量控制，拥塞控制和顺序交付的
1. 可靠传输：
	**序列号和确认号**： isn和isn+1 ack，发送方将数据包按序列号进行发送，接收方通过确认序列号告知已经接收到数据；
	**超时重传**：一段时间内发送方没能收到ack确认收到数据，将重传数据包确保数据的可靠性，发送方在收到接收方的ack后会重新更新计时器，停止重传数据包，并继续发送下一个数据包；如果已经超过了**最大重传次数**仍未能收到确认，发送方会终止连接报告==应用层==连接异常；`这里应用层是什么？`另一些情况发送方可能认为网络出现了拥塞，或者通知应用层（比如http协议？）；
	**累积确认**：允许接收方一次性确认已经接收到的连续字节范围，`例如，假设接收方已经成功接收了字节序列号为1到100的数据，但由于TCP是一个字节流协议，接收方并不需要对每个字节都发送确认。接收方可以简单地发送一个确认号为101的确认报文，表示下一个期望接收的字节序列号是101，即已经成功接收了1到100的数据。`
	`RTT（往返时延): 数据从发送到收到对方响应之间的时间间隔`
	再介绍介绍累积确认：如果发送方发送了1、2、3三个报文段，先发送了2、3存在接收方的缓存区，但接收方希望接收到1，这时候如果1一直不到，报文2、3也会被丢弃；1接收到了，接收方会发送1个ack对3个报文进行一次确认`表示已经成功接收了该确认号之前的所有数据。但确认号可以代表接收方希望接收到的下一个字节的序列号`

2. 流量控制：（滑动窗口：如果发送的数据量比较大，使用一应一达的方式发送数据就比较慢）
	**滑动窗口，发送方窗口**：首先分为两部分，一部分是已经发送但没得到应答的数据，第二部分是还没发送的数据
	**接收方窗口，接收方的缓冲区**：控制发送方发送数据的速度，确保发送方不会发送过多数据导致接收方无法处理，窗口就是不需要等待确认应答包就可以继续发送数据包的最大值
	滑动窗口的动态调整：接收端根据自己的情况告知滑动窗口的大小，从而控制发送端的接收，进行流量控制；**第一次的窗口大小是根据链路带宽的大小决定的，接收端会告诉发送端自己希望接收到的数据包是多少，调整窗口的大小**，
	**窗口探测**：当窗口设置为0时，不能接收任何数据，但再次能接受数据时，会发一个通知，告诉发送端可以接收数据了；于此同时发送端也会偶尔发送1字节的窗口探测包，用来获取最新的窗口大小信息；

3. 拥塞控制：拥塞窗口；慢启动、拥塞避免、快速重传、快速恢复
	**拥塞窗口**（一个状态变量）：慢启动为发送方的tcp增加了另一个窗口拥塞窗口cwnd，每收到一个ack拥塞窗口就增加一个报文段，每次发送数据包，拥塞窗口和接收端主机反馈的窗口大小做对比，取较小的值作为实际的发送窗口；
	- 慢启动：cwnd的值一开始设置为1，发送窗口swnd等于拥塞窗口cwnd，所以发送一个报文，然后收到一个ack变成2，然后收到两个ack变成4...指数增加；直到等于慢启动门限值，进入拥塞避免算法；
	- 拥塞避免：从指数增长变成线性增长，直到发生超时重传，就再从1开始发送；

![[Pasted image 20240715120821.png]]
- 快速重传：在`超时重传`前就把需要重发的报文发送了（收到了三个重复确认，可见不是由于拥塞二十丢失个别报文）
- 快恢复：因为只是丢了个别的报文段，不启动慢启动，而是用快速恢复，发送方将门限值和cwnd调整为当前窗口的一半



4. 顺序交付：通过序列号和确认号，保证数据包按顺序交付；


### UDP协议相关
1. UDP用户数据报协议是一种面向无连接的传输协议，与TCP协议相比UDP不提供==数据包的可靠传输、流量控制、拥塞控制和顺序交付等功能==


# 网络编程
**reactor模型**和**proactor模型**
## reactor模型
- reactor：负责监听和分配时间，将io时间分配给对应的handler
- acceptor：处理客户端的新连接，放入处理器链中
- handler：将自身与事件绑定，执行非阻塞读写任务，完成channel的读入

![[Pasted image 20240711171857.png]]
在主从Reactor多线程模型中，父线程与子线程之间数据交互简单、责任明确，`父线程只需接收新连接，后续的处理交给子线程完成即可`；主从Reactor多线程模型中，Reactor线程拆分为`mainReactor`和`subReactor`两个部分，mainReactor只处理连接事件，读写事件交给subReactor来处理。
`业务逻辑还是由线程池来处理`，mainRactor只处理连接事件，用一个线程来处理就好。处理读写事件的subReactor个数一般和CPU数量相等，一个subReactor对应一个线程，业务逻辑由线程池处理

```cpp
int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
//这里的nfds是就绪事件的个数
if (events[i].events & EPOLLIN) 
```
events是一个位掩码通过位运算来检查包含到事件类型；
- `EPOLLIN`：表示文件描述符上有数据可读。
- `EPOLLOUT`：表示文件描述符上可以写入数据。
- `EPOLLERR`：表示文件描述符上发生了错误。
- `EPOLLHUP`：表示文件描述符被挂起。
Epoll有三个系统调用：`epoll_create()`\ `epoll_ctl()`\ `epoll_wait()`
- 执行epoll_create()会创建一个红黑树，和一个就绪链表(放已经就绪的文件描述符)，为系统可以打开的最大文件描述符数
- epoll_ctl()函数将epoll_event结构体拷贝传入内核，内核会在红黑树上添加相应的结点，并注册回调函数ep_poll_callback()，内核在检测到某文件描述符可读/可写时就调用回调函数callback,该回调函数将文件描述符放入就绪链表rdllist中。
- epoll_wait()函数只需要观察rdllist中有无就绪的文件描述符即可，内核将就绪的文件描述符事件复制到传入的poll_event结构体数组中返回给用户空间，所以用户只用遍历依次处理即可，即应用程序索引就绪文件描述符的时间复杂度是O（1）
```cpp
// 处理事件
for (int i = 0; i < nfds; ++i) {
    if (events[i].events & EPOLLIN) {
        // 调用读取数据的回调函数
        read_callback(events[i].data.fd);
    }
    // 其他事件处理...
}

// 读取数据的回调函数
void read_callback(int sockfd) {
    // 读取数据并处理
}

```

# MySQL相关
#### 最重要的写sql的时候的顺序
```sql
from
join on
where
group by
having
order by
```

#TODO{p698索引相关}
#### B树和B+树
- 同样的数据量级别，B+树比B树低，磁盘io更少；所有的叶子节点用双向链表连接，更适合范围查询
- 和红黑树，红黑树是二叉树，深度更大意味查找的次数更多，会进行更频繁的磁盘io
#### 索引的优势和劣势
- `什么时候适合用索引`：字段有唯一性的限制、经常需要被查询、经常需要group by或者order by的字段 *经常需要查找，经常需要范围查找，经常需要排序*的列
- `什么时候不需要索引`：数据太少、经常更新的字段、存在大量的重复数据；
- `什么时候索引会失效`：`like %xx` 或者`like %xxx%` 左或者左右模糊匹配的时候、对索引列做了计算或者类型转换操作
- `WHERE OR `：or前的条件列是索引列，or后不是索引列，索引就会失效；
`优化索引的方法`：前缀索引优化；覆盖索引优化；主键索引最好是自增的；防止索引失效；

### 事务的四大特性(ACID)
A:原子性，要不全部完成要不整个事物都不完成
C：一致性，数据库的完整性不会被破坏，写入的资料完全符合预设规则；
I：隔离性，允许并发事物进行读写和修改的能力，数据的隔离程度包括：`串行化`、`可重复读`、`读提交（事务提交后结果才会被看到）`、`读未提交`；
D: 持久性：事件之后，对数据的修改就是永久的，故障也不会丢失；

#### 隔离性可能出现的问题有
1. 脏读：A修改了数据，B读到了A修改后的数据，但A修改失败了，B读到的数据就是错误的数据；
2. 不可重复读：在同一个事务范围内，对同一份数据两个相同的查询得到的结果不一致；
3. 幻读：在同一个事务范围内，两次查询结果不一致，原因是因为插入了新的数据，无法通过加锁的方式解决，只能通过事务串行；
可重复读：（`Next-key`锁，锁定一个数据行和其相邻的间隙，避免其中插入新的数据，保持一致性）、（间隙锁，锁定一个范围避免插入新数据，解决幻读问题）*无法完全解决幻读问题 mysql使用的next-key锁可以解决幻读问题*

### 关系型数据库和非关系型数据库的优缺点
- 关系型数据库的优点：保持数据的一致性，数据更新的开销比较小，支持复杂的查询比如where
- 非关系型数据库的优点：读写效率更高，基于键值对对数据的拓展性更好，可以支持多种类型数据的存储比如图片文档等等；

`非关系型数据库的分类和比较：文档型、key-value、列式数据库、图形数据库`

### 主键、联合主键和自增
- 主键：用于唯一标识表中的每一条数据，不能重复不能为空
- 联合主键：如果一个字段不能确定唯一性的时候，需要其他字段来一起形成唯一性，就是联合主键；

### 普通索引和唯一索引
- 对于唯一索引找到3和5之间的位置判断没有冲突然后插入，如果是普通索引就是少了判断冲突的过程；
- 但如果目标页并不在内存中时，如果是唯一索引，就需要读入内存中判断是否有冲突，然后语句结束；但普通索引只需要记录在change buffer中，不用在内存中读页；`change buffer因为减少了随机磁盘访问，所以对更新性能的提升会很明显。`
- 什么是change buffer：更新数据页的时候，如果页不在内存中，就先记录在change buffer中，change buffer在内存中有拷贝，也会被写入到磁盘上；将 change buffer中的操作应用到原数据页，得到最新结果的过程称为 merge。
主键索引和唯一索引谁比较快：主键索引直接搜到的一整条数据，非主键索引搜索到的是主键，也就是说非主键索引至少要要查找两棵树；
#### 索引在物理层面分类也可以分为 聚集索引和非聚集索引
- 聚集索引，数据在物理存储中的顺序跟索引中数据的逻辑顺序相同
- 非聚集索引：数据在物理存储的顺序和索引中数据的逻辑顺序不同

**覆盖索引**：如果一个索引包含所有需要查询的字段的值，我们就称之为覆盖索引；`当一个查询语句可以通过索引就能返回所需的数据，而不必再去访问表中的实际数据行时，就称为覆盖索引。`

### 数据库中的主键、超键、候选键、外键是什么
- 超键：可以唯一的标识元组的属性集合
- 候选键：最小的超键，不能再删除任何一个属性而保持唯一性
- 主键：用于元组标识的一个候选键作为主键
- 外键：key是其他表格中的主键，在这个表中就是一个外键；



### 全文索引
- 全文索引只能为`char varchar text`列创建；
```sql
CREATE TABLE articles (
    id INT PRIMARY KEY,
    content TEXT
);

INSERT INTO articles (id, content) VALUES
(1, 'This is the content of article 1.'),
(2, 'Another article with some text.'),
(3, 'Lorem ipsum dolor sit amet.');

// 创建全文索引
ALTER TABLE articles ADD FULLTEXT(content);
// 使用全文索引进行检索
SELECT * FROM articles WHERE MATCH(content) AGAINST('text');
```


### Mysql执行查询语句内部执行的过程
1. 连接器：客户端通过连接器连接到mysql服务器
2. 缓存：检查是否有查询缓存，如果有查询缓存直接返回缓存中的数据，如果没有缓存进入分析器
3. 分析器：判断sql是否正确，正确返回优化器
4. 优化器：对查询语句进行优化处理
5. 执行器：执行语句查询满足条件的所有数据然后进行返回；

### Mysql的优化 索引优化和性能优化
- **高频访问**：`分表分库`（将表进行水平拆分，减少表的长度）、`增加缓存`（在web和DB之间加上一层缓存层）、`增加数据库的索引`（在适合的字段上加上索引，解决高频访问问题）；

- **并发优化**：`主从读写分离`（在主服务器上写，从服务器上读），`负载均衡集群`（通过集群或者分布式的方式解决并发压力）

### mysql索引主要使用的两种数据结构分别是什么
- 哈希索引：主要针对经常被访问的数据，建立针对单条记录的查询
- B树索引：b+树 范围查询；

### Innodb和Myisam
1. InnoDB支持事务，MyISAM不支持事务，最好把多条sql语言放在begin和commit之间，组成一个事务；
2. InnoDB支持外键
3. InnoDB是聚集索引，数据文件和主键索引绑在一起；主键不宜过大，主键过大其他索引也会很大；必须有唯一索引如主键；
4. InnoDB支持表、行级锁

### Innodb为什么使用自增ID作为主键
- 自增ID可以保证每次插入B+树都是从右边拓展的，可以避免B+树和频繁合并和分裂；使用字符串主键和随机主键，会随机插入，改变B+树的结构；

### Innodb的四大特性
`插入缓冲`,`二次写`,`自适应哈希索引`,`预读`
`插入缓冲`：change buffer 数据被先写入插入缓冲区，等后台合适的时机再插入主索引中，减少了磁盘IO，提高了插入的性能；
`二次写`：InnoDB首先将数据写入一个`doublewrite buffer`的缓冲区，再将数据写入实际数据文件中，可以避免发生意外时数据文件损坏；这个缓冲区通常在数据文件和日志文件之间；
`自适应哈希索引`：InnoDB会根据查询的频率和模式自动创建和维护哈希索引，用于加速对数据的访问；
`预读`：会预先读取磁盘上的数据页到内存中共，以便能更快的访问，减少磁盘io的次数，提高查询性能；

### DROP DELETE TRUNCATE的共同点和区别
drop：删除一整张表包括表结构
truncate：删除表中的所有数据，重置自增列的值为初始值`TRUNCATE TABLE`不可回滚
delete：删除某一部分的数据行，可以回滚，可以加where子句

### 什么是视图什么是游标
数据库视图（View）：基于一个或多个表的查询结果集合
`视图就相当于一个虚表，其实本质就是一个查询，我们不可以插入删除等，但是它会随着创建它的select的结果改变而改变，所以它本质上就是一个查询（视图本身不可修改，但是视图中的来源是可以修改的）`
```sql
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
```
1. **简化复杂查询**：通过视图可以将复杂的查询逻辑封装在视图中，简化用户的查询操作。
2. **数据安全**：可以限制用户只能访问视图中的特定数据，保护敏感数据。
3. **提高数据独立性**：视图可以隐藏底层表的结构变化，提高数据和应用程序之间的独立性。
**游标的作用有**：逐行处理数据、数据导航、数据操作、复杂数据处理；


# Redis相关

### Redis有哪些数据类型
- 字符串，列表(list双向链表)，集合set，有序集合Zset，哈希表hash散列
- 后续又支持四种数据类型：BitMap二值状态统计场景、HyperLogLog、GEO存储地理位置、Stream消息队列
`HyperLogLog（HLL）`是一种概率性数据结构，用于对大数据集合的基数（不重复元素的数量）进行估计。它的设计目的是在占用较少内存的情况下，能够高效地估计一个数据集合的基数。

- 数据结构（底层）：简单动态字符串`char`，链表，字典map，跳表（有序集合的底层实现之一，跳表的层高是1-32之间的随机数），压缩列表：

### Redis的好处有那些
1. 访问速度快
2. 数据类型丰富
3. 支持事务，操作是原子性的（因为是单线程的）
在内存中操作，采用单线程避免上下文切换，采用非阻塞io多路复用机制；


### 设置过期时间
- `定期删除`：Redis默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 Redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！ 
- `惰性删除 `：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。它是指某个键值过期后,此键值不会马上被删除,而是等到下次被使用的时候,才会被检查到过期,此时才能得到删除,惰性删除的缺点很明显是浪费内存。除非你的系统去查一下那个 key，才会被Redis给删除掉。这就是所谓的惰性删除！
- `定期删除（Eviction）`：
- **定义**：定期删除是指在 Redis 内存使用达到上限时，根据一定的策略主动删除一些数据，从而腾出空间给新的数据。
- **策略**：常见的定期删除策略包括 LRU（Least Recently Used，最近最少使用）和 LFU（Least Frequently Used，最不经常使用）等，根据数据的访问模式来选择删除哪些数据。

### 缓存雪崩、缓存穿透
- `缓存雪崩`：内存中的数据由于设置了相同的过期时间，同时被清理，导致很多请求直接跨过内存访问数据库或者服务端；相同的过期时间因为第一次请求的时候请求时间就是相同的...
*缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。比如常见的电商项目中，某些货物成为“爆款”了，可以对一些主打商品的缓存直接设置为永不过期。*
- `缓存穿透`：查询不存在的数据一定会请求数据库查询，（这里的数据库指的是mysql数据库用redis做内存缓冲）
	1. 布隆过滤器：将所有存在的数据放入一个bitmap中，一定不存在的数据会被bitmap过滤掉；
	2. 缓存空对象：对请求后不存在的对象缓存起来，在设置一个过期时间（方法不太好吧感觉）
- `缓存预热`：系统上线后，先将缓存数据加载到缓存系统中
- `缓存更新`：定期清理过期的缓存，当有用户请求时判断缓存是否过期
- `缓存降级`：服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做









